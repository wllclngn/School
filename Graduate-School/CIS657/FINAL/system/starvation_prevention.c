/* starvation_prevention.c - Implementation of starvation prevention mechanisms
 * Generated on: 2025-06-16 01:39:36
 * Generated by: mol
 * This file implements the starvation prevention mechanisms for the simulation
 */

#include "../xinu_includes.h"

/* Global variables are defined in xinu_includes.h */

/* Function prototypes for processes */
void p1_func(void);
void p2_func(void);
void pstarv_func(void);

/*
 * boost_pstarv_priority - Boost the priority of the starving process
 * Used for Question 1: Boost priority after context switch
 */
void boost_pstarv_priority(void) {
    struct procent *prptr;  /* Pointer to process table entry */
    
    /* Check if the pstarv process exists and starvation prevention is enabled */
    if (pstarv_pid == BADPID || !enable_starvation_fix) {
        return;
    }
    
    /* Check if the process is in the ready state */
    prptr = &proctab[pstarv_pid];
    if (prptr->prstate != PR_READY) {
        return;
    }
    
    /* Boost the priority by 2 (can be adjusted) */
    prptr->prprio += 2;
    
    /* Print status message */
    kprintf("\nBOOST: PStarv priority increased from %d to %d\n\n", 
            prptr->prprio - 2, prptr->prprio);
}

/*
 * check_pstarv_time - Check if the starving process has been waiting too long
 * Used for Question 2: Time-based priority boosting
 */
void check_pstarv_time(void) {
    struct procent *prptr;  /* Pointer to process table entry */
    uint32 current_time;   /* Current system time */
    
    /* Check if the pstarv process exists and starvation prevention is enabled */
    if (pstarv_pid == BADPID || !enable_starvation_fix) {
        return;
    }
    
    /* Check if the process is in the ready state */
    prptr = &proctab[pstarv_pid];
    if (prptr->prstate != PR_READY) {
        return;
    }
    
    /* Get current time */
    current_time = clktime;
    
    /* Check if 2 seconds have passed since the last boost */
    if (current_time >= last_boost_time + 2) {
        /* Boost priority */
        prptr->prprio += 2;
        
        /* Update last boost time */
        last_boost_time = current_time;
        
        /* Print status message */
        kprintf("\nTIME BOOST: PStarv priority increased from %d to %d at time %d\n\n", 
                prptr->prprio - 2, prptr->prprio, current_time);
    }
}

/*
 * p1_func - Process 1 function 
 */
void p1_func(void) {
    int i;
    
    kprintf("\n!!!!!!!!!! P1 (PID: %d, Prio: %d) HAS STARTED !!!!!!!!!!\n", 
            getpid(), proctab[getpid()].prprio);
    
    /* Run for a while */
    for (i = 1; i <= 15; i++) {
        /* Simulate some work */
        kprintf("P1 (PID: %d, Prio: %d) is running (iteration %d/15)\n", 
                getpid(), proctab[getpid()].prprio, i);
        
        /* Yield CPU occasionally to allow context switch */
        if (i % 3 == 0) {
            yield();
        }
    }
    
    kprintf("\nP1 (PID: %d) finished.\n", getpid());
}

/*
 * p2_func - Process 2 function
 */
void p2_func(void) {
    int i;
    
    kprintf("\n##### P2 (PID: %d, Prio: %d) HAS STARTED #####\n", 
            getpid(), proctab[getpid()].prprio);
    
    /* Run for a while */
    for (i = 1; i <= 15; i++) {
        /* Simulate some work */
        kprintf("P2 (PID: %d, Prio: %d) is running (iteration %d/15)\n", 
                getpid(), proctab[getpid()].prprio, i);
        
        /* Yield CPU occasionally to allow context switch */
        if (i % 3 == 0) {
            yield();
        }
    }
    
    kprintf("\nP2 (PID: %d) finished.\n", getpid());
}

/*
 * pstarv_func - Starving process function
 */
void pstarv_func(void) {
    int i;
    
    kprintf("\n!!!!!!!!!! PStarv (PID: %d, Prio: %d) HAS STARTED !!!!!!!!!!\n", 
            getpid(), proctab[getpid()].prprio);
    
    /* Celebration message */
    kprintf("\n##########################################################################\n");
    kprintf("PStarv (PID: %d, Prio: %d) IS FINALLY RUNNING! Priority boosting works!\n", 
            getpid(), proctab[getpid()].prprio);
    kprintf("##########################################################################\n\n");
    
    /* Run for a while */
    for (i = 1; i <= 15; i++) {
        /* Simulate some work */
        kprintf("PStarv (PID: %d, Prio: %d) is running (iteration %d/15)\n", 
                getpid(), proctab[getpid()].prprio, i);
    }
    
    kprintf("\nPStarv (PID: %d) finished.\n", getpid());
}

/*
 * starvation_test_Q1 - Shell command to test Q1 starvation prevention
 * (context switch based priority boosting)
 */
int starvation_test_Q1(int nargs, char *args[]) {
    /* Create processes with different priorities */
    kprintf("\nStarting starvation simulation for Q1 (context switch based)...\n");
    
    /* Reset global variables */
    enable_starvation_fix = TRUE;
    
    /* Create the processes */
    pid32 p1_pid = create(p1_func, 1024, 40, "P1", 0);
    pid32 p2_pid = create(p2_func, 1024, 35, "P2", 0);
    pstarv_pid = create(pstarv_func, 1024, 25, "PStarv", 0);
    
    kprintf("P1, P2, and PStarv processes created with priorities 40, 35, and 25\n");
    
    /* Resume the processes to start execution */
    resume(p1_pid);
    resume(p2_pid);
    resume(pstarv_pid);
    
    kprintf("All processes resumed. Starting execution...\n");
    kprintf("=========== END OF SHELL SETUP ===========\n\n");
    
    return 0;
}

/*
 * starvation_test_Q2 - Shell command to test Q2 starvation prevention
 * (time-based priority boosting)
 */
int starvation_test_Q2(int nargs, char *args[]) {
    /* Create processes with different priorities */
    kprintf("\nStarting starvation simulation for Q2 (time based)...\n");
    
    /* Reset global variables */
    enable_starvation_fix = TRUE;
    pstarv_ready_time = clktime;
    last_boost_time = clktime;
    
    /* Create the processes */
    pid32 p1_pid = create(p1_func, 1024, 40, "P1", 0);
    pid32 p2_pid = create(p2_func, 1024, 35, "P2", 0);
    pstarv_pid = create(pstarv_func, 1024, 25, "PStarv", 0);
    
    kprintf("P1, P2, and PStarv processes created with priorities 40, 35, and 25\n");
    
    /* Resume the processes to start execution */
    resume(p1_pid);
    resume(p2_pid);
    resume(pstarv_pid);
    
    kprintf("All processes resumed. Starting execution...\n");
    kprintf("=========== END OF SHELL SETUP ===========\n\n");
    
    return 0;
}
