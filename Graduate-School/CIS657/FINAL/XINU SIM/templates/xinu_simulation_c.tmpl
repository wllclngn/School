/* xinu_simulation.c - Helper functions for UNIX-like Simulation
 * Generated by {{ generator }}
 * Generated on: {{ timestamp }}
 * By user: {{ user }}
 */
#include "xinu_includes.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <time.h>

/* Standard IO redirects */
int xinu_printf_sim_redirect(const char *format, ...) {
    va_list args; int ret; va_start(args, format); ret = vprintf(format, args); va_end(args); fflush(stdout); return ret;
}

int xinu_fprintf_sim_redirect(void *stream, const char *format, ...) {
    FILE *f = (FILE*)stream;
    va_list args; int ret; va_start(args, format); ret = vfprintf(f, format, args); va_end(args); 
    if (f) fflush(f); 
    return ret;
}

int xinu_sprintf_sim_redirect(char *buffer, const char *format, ...) {
    va_list args; int ret; va_start(args, format); ret = vsprintf(buffer, format, args); va_end(args); return ret;
}

int xinu_scanf_sim_redirect(const char *format, ...) {
    va_list args; int ret; va_start(args, format); ret = vscanf(format, args); va_end(args); return ret;
}

int xinu_fscanf_sim_redirect(void *stream, const char *format, ...) {
    FILE *f = (FILE*)stream;
    va_list args; int ret; va_start(args, format); ret = vfscanf(f, format, args); va_end(args); return ret;
}

int xinu_sscanf_sim_redirect(const char *buffer, const char *format, ...) {
    va_list args; int ret; va_start(args, format); ret = vsscanf(buffer, format, args); va_end(args); return ret;
}

int xinu_getchar_sim_redirect(void) { 
    return getchar(); 
}

int xinu_putchar_sim_redirect(int c) { 
    int ret = putchar(c); 
    fflush(stdout); 
    return ret; 
}

int xinu_fgetc_sim_redirect(void *stream) { 
    return fgetc((FILE*)stream); 
}

char* xinu_fgets_sim_redirect(char *str, int num, void *stream) { 
    return fgets(str, num, (FILE*)stream); 
}

int xinu_fputc_sim_redirect(int c, void *stream) { 
    int ret = fputc(c, (FILE*)stream); 
    fflush((FILE*)stream); 
    return ret; 
}

int xinu_fputs_sim_redirect(const char *str, void *stream) { 
    int ret = fputs(str, (FILE*)stream); 
    fflush((FILE*)stream); 
    return ret; 
}

/* Format string handlers */
int xinu_doprnt_sim_redirect(char *fmt, va_list ap, xinu_putc_func_t putc_func, int putc_arg) {
    char buffer[4096]; 
    int ret = vsprintf(buffer, fmt, ap); 
    if (putc_func) { for (int i = 0; i < ret; ++i) { putc_func(buffer[i], putc_arg); } }
    return ret;
}

int xinu_doscan_sim_redirect(char *fmt, va_list ap, xinu_doscan_getc_func_t getc_func, 
                             xinu_doscan_ungetc_func_t ungetc_func, int getc_arg, int ungetc_arg) {
    /* 
     * This is a functional implementation of the doscan shim that works with standard C I/O functions.
     * It creates a temporary buffer from the input stream, then uses sscanf to parse according to
     * the format string.
     */
    if (!fmt) {
        return -1;  /* Invalid arguments */
    }
    
    /* Build a temporary buffer from the input stream */
    char buffer[4096] = {0};  /* Use a reasonably large buffer */
    int i = 0;
    int c;
    
    if (getc_func) {
        /* Read characters until EOF or buffer full */
        while (i < 4095) {
            c = getc_func(getc_arg);
            if (c == EOF || c < 0) break;
            buffer[i++] = (char)c;
        }
        buffer[i] = '\0';  /* Ensure null-termination */
    }
    
    /* Use standard sscanf to parse the buffer */
    return vsscanf(buffer, fmt, ap);
}

/* Standard Library redirects */
int xinu_abs_sim_redirect(int n) { return abs(n); }
long xinu_labs_sim_redirect(long n) { return labs(n); }
int xinu_atoi_sim_redirect(const char *str) { return atoi((char*)str); }
long xinu_atol_sim_redirect(const char *str) { return atol((char*)str); }
int xinu_rand_sim_redirect(void) { return rand(); }
void xinu_srand_sim_redirect(unsigned int seed) { srand(seed); }
void xinu_qsort_sim_redirect(void *base, size_t num, size_t size, xinu_qsort_cmp_t compare) {
    qsort(base, num, size, compare);
}

/* String handling redirects */
char* xinu_strcpy_sim_redirect(char *dest, const char *src) { return strcpy(dest, (char*)src); }
char* xinu_strncpy_sim_redirect(char *dest, const char *src, size_t n) { return strncpy(dest, (char*)src, n); }
char* xinu_strcat_sim_redirect(char *dest, const char *src) { return strcat(dest, (char*)src); }
char* xinu_strncat_sim_redirect(char *dest, const char *src, size_t n) { return strncat(dest, (char*)src, n); }
int xinu_strcmp_sim_redirect(const char *s1, const char *s2) { return strcmp((char*)s1, (char*)s2); }
int xinu_strncmp_sim_redirect(const char *s1, const char *s2, size_t n) { return strncmp((char*)s1, (char*)s2, n); }
size_t xinu_strlen_sim_redirect(const char *s) { return strlen((char*)s); }
size_t xinu_strnlen_sim_redirect(const char *s, size_t maxlen) {
#if defined(_WIN32) && defined(__STDC_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ && defined(strnlen_s)
    return strnlen_s((char*)s, maxlen);
#elif defined(__linux__) || defined(__APPLE__) || defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809L
    return strnlen((char*)s, maxlen);
#else 
    size_t i = 0; while (i < maxlen && s[i]) { ++i; } return i;
#endif
}
char* xinu_strchr_sim_redirect(const char *s, int c) { return strchr((char*)s, c); }
char* xinu_strrchr_sim_redirect(const char *s, int c) { return strrchr((char*)s, c); }
char* xinu_strstr_sim_redirect(const char *haystack, const char *needle) { return strstr((char*)haystack, (char*)needle); }
void* xinu_memcpy_sim_redirect(void *dest, const void *src, size_t n) { return memcpy(dest, src, n); }
void* xinu_memmove_sim_redirect(void *dest, const void *src, size_t n) { return memmove(dest, src, n); }
int xinu_memcmp_sim_redirect(const void *s1, const void *s2, size_t n) { return memcmp(s1, s2, n); }
void* xinu_memset_sim_redirect(void *s, int c, size_t n) { return memset(s, c, n); }

/* Simulation helpers */
void xinu_simulation_yield(void) {
    /* Simulation of XINU's yield() operation.
     * In a real simulation environment, this would actually yield to other processes.
     * For now, it's just a placeholder.
     */
}

void xinu_trigger_clock_interrupt(void) {
    /* Simulation of a clock interrupt to trigger rescheduling.
     * In a real simulation environment, this would invoke the clock interrupt handler.
     * For now, it's just a placeholder.
     */
}

/* Minimal XINU-like system call implementations */
int resched(void) { return 0; }
int resume(int pid) { return 0; }
int kill(int pid) { return 0; }
int sleep(unsigned int delay) { return 0; }
int sleepms(unsigned int delay) { return 0; }
int yield(void) { xinu_simulation_yield(); return 0; }