"""
generator.py - XINU file generator
"""

import os
import re
import glob
from datetime import datetime
from xinu_builder.utils.logger import log

class XinuGenerator:
    """Generator for XINU simulation files"""
    
    def __init__(self, config):
        self.config = config
        # Functions to exclude/shim
        self.exclude_funcs = [
            "printf", "fprintf", "sprintf", "scanf", "fscanf", "sscanf",
            "getchar", "putchar", "fgetc", "fgets", "fputc", "fputs",
            "_doprnt", "_doscan", "abs", "labs", "atoi", "atol", 
            "rand", "srand", "qsort", "strcpy", "strncpy", "strcat", 
            "strncat", "strcmp", "strncmp", "strlen", "strnlen", 
            "strchr", "strrchr", "strstr", "memcpy", "memmove", 
            "memcmp", "memset"
        ]
        
        # Load the master template file
        self.templates = {}
        self._load_templates()
        
    def _load_templates(self):
        """Load all templates from the master template file"""
        master_template_path = os.path.join(self.config.project_dir, "xinu_builder/templates/xinu_templates.tmpl")
        
        try:
            with open(master_template_path, 'r') as f:
                content = f.read()
                
            # Parse sections using regex
            section_pattern = r'### BEGIN (\w+) ###\n(.*?)### END \1 ###'
            matches = re.finditer(section_pattern, content, re.DOTALL)
            
            for match in matches:
                section_name = match.group(1)
                section_content = match.group(2)
                self.templates[section_name] = section_content
                
            log(f"Loaded {len(self.templates)} template sections from {master_template_path}")
            
        except FileNotFoundError:
            log(f"ERROR: Template file not found: {master_template_path}")
            log("Using fallback hardcoded templates")
            self._setup_fallback_templates()
        except Exception as e:
            log(f"ERROR: Failed to load templates from {master_template_path}: {str(e)}")
            log("Using fallback hardcoded templates")
            self._setup_fallback_templates()
    
    def _setup_fallback_templates(self):
        """Setup fallback hardcoded templates if the file can't be loaded"""
        self.templates["XINU_STDDEFS_H"] = """/* xinu_stddefs.h - Generated by xinu_generator.py */
#ifndef _XINU_STDDEFS_H_
#define _XINU_STDDEFS_H_

/* Basic XINU type definitions */
typedef void exchandler;
typedef int message;
typedef int syscall;
typedef int process;
typedef int int32;
typedef unsigned int uint32;
typedef int bool32;
typedef int did32;
typedef int pid32;
typedef int status;

/* Process state constants */
#define PR_FREE      0       /* Process table entry is unused              */
#define PR_CURR      1       /* Process is currently running               */
#define PR_READY     2       /* Process is on ready queue                  */
#define PR_RECV      3       /* Process waiting for message                */
#define PR_SLEEP     4       /* Process is sleeping                        */
#define PR_SUSP      5       /* Process is suspended                       */
#define PR_WAIT      6       /* Process is on semaphore queue              */
#define PR_RECTIM    7       /* Process is receiving with timeout          */

/* Error/status codes */
#define OK            1      /* System call returns OK                     */
#define SYSERR       -1      /* System call returns error                  */
#define SHELL_OK      1      /* Shell command returns OK                   */
#define SHELL_ERROR  -1      /* Shell command returns error                */
#define BADPID       -1      /* Error process ID                           */

/* Other common definitions */
#define NULL         0       /* Null pointer                               */
#define EOF         -2       /* End-of-file                                */

#endif /* _XINU_STDDEFS_H_ */
"""

        # Add other fallback templates (shortened for brevity here)
        self.templates["XINU_H"] = "/* Fallback xinu.h template */"
        self.templates["XINU_INCLUDES_H"] = "/* Fallback xinu_includes.h template */"
        self.templates["XINU_SIM_DECLARATIONS_H"] = "/* Fallback xinu_sim_declarations.h template */"
        self.templates["XINU_SIMULATION_C"] = "/* Fallback xinu_simulation.c template */"
        self.templates["XINU_CORE_C"] = "/* Fallback xinu_core.c template */"
        
    def _render_template(self, template_name, context=None):
        """Render a template with variable replacements"""
        if context is None:
            context = {}
            
        # Make sure we have the template
        if template_name not in self.templates:
            log(f"ERROR: Template '{template_name}' not found")
            return f"/* Error: Template {template_name} not found */"
            
        template = self.templates[template_name]
        
        # Add standard context variables
        full_context = {
            "generator": "xinu_generator.py",
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "user": os.environ.get("USER", os.environ.get("USERNAME", "unknown"))
        }
        full_context.update(context)
        
        # Replace variables in the template
        result = template
        for key, value in full_context.items():
            result = result.replace(f"{{{{ {key} }}}}", str(value))
            
        return result
        
    def generate_all_files(self):
        """Generate all XINU simulation files"""
        self.generate_stddefs()
        self.update_xinu_h()
        self.generate_includes_h()
        self.generate_sim_declarations()
        self.generate_sim_helper()
        self.generate_xinu_core()
        self.auto_insert_includes()
        
    def generate_stddefs(self):
        """Generate xinu_stddefs.h with type definitions"""
        content = self._render_template("XINU_STDDEFS_H")
        
        with open(self.config.stddefs_h, 'w') as f:
            f.write(content)
            
        log(f"Generated XINU stddefs: {self.config.stddefs_h}")
        
    def update_xinu_h(self):
        """Update or create xinu.h with dynamic module includes"""
        xinu_h_path = self.config.xinu_h
        
        # Create xinu.h if it doesn't exist
        if not os.path.exists(xinu_h_path):
            content = self._render_template("XINU_H")
            with open(xinu_h_path, 'w') as f:
                f.write(content)
            log(f"Created {xinu_h_path}")
        
        # Now update the module includes
        self._update_module_includes()
        
    def _update_module_includes(self):
        """Update the dynamic module includes section in xinu.h"""
        xinu_h_path = self.config.xinu_h
        begin_marker = "/// [[[ BEGIN DYNAMIC XINU MODULE INCLUDES ]]]"
        end_marker = "/// [[[ END DYNAMIC XINU MODULE INCLUDES ]]]"
        
        try:
            with open(xinu_h_path, 'r') as f:
                content = f.read()
                
            # Check if markers exist
            if begin_marker not in content or end_marker not in content:
                log(f"Adding module include markers to {xinu_h_path}")
                # Insert markers if they don't exist
                updated_content = re.sub(
                    r'#endif\s*/\*\s*_XINU_H_\s*\*/',
                    f"/* Include all other header files */\n{begin_marker}\n{end_marker}\n\n#endif /* _XINU_H_ */",
                    content
                )
                with open(xinu_h_path, 'w') as f:
                    f.write(updated_content)
                content = updated_content
            
            # Find the section between markers
            begin_idx = content.find(begin_marker) + len(begin_marker)
            end_idx = content.find(end_marker)
            
            if begin_idx > 0 and end_idx > begin_idx:
                # Create the updated dynamic includes
                module_includes = []
                
                # Find all header files in include directory
                include_files = glob.glob(os.path.join(self.config.include_dir, "*.h"))
                for header_path in include_files:
                    header_name = os.path.basename(header_path)
                    if header_name not in ["xinu.h", "stddef.h", "stdint.h", "xinu_stddefs.h"]:
                        module_includes.append(f'#include <{header_name}>\n')
                
                # Sort the includes alphabetically
                module_includes.sort()
                
                # Create the updated content
                updated_content = (
                    content[:begin_idx] + 
                    "\n" + 
                    "".join(module_includes) + 
                    content[end_idx:]
                )
                
                # Save a backup
                with open(f"{xinu_h_path}.bak", 'w') as f:
                    f.write(content)
                
                # Write the updated file
                with open(xinu_h_path, 'w') as f:
                    f.write(updated_content)
                
                log(f"Updated module includes in {xinu_h_path}")
                log("WARNING: Module include order is ALPHABETICAL and may NOT respect dependencies!")
                
        except Exception as e:
            log(f"Error updating module includes in {xinu_h_path}: {str(e)}")
            
    def generate_includes_h(self):
        """Generate xinu_includes.h wrapper"""
        content = self._render_template("XINU_INCLUDES_H")
        
        with open(self.config.includes_h, 'w') as f:
            f.write(content)
            
        log(f"Generated UNIX-like simulation includes wrapper at: {self.config.includes_h}")

    def generate_sim_declarations(self):
        """Generate xinu_sim_declarations.h with function declarations"""
        content = self._render_template("XINU_SIM_DECLARATIONS_H")
        
        with open(self.config.sim_decls_h, 'w') as f:
            f.write(content)
            
        log(f"Generated UNIX-like simulation declarations at: {self.config.sim_decls_h}")

    def generate_sim_helper(self):
        """Generate xinu_simulation.c with function implementations"""
        content = self._render_template("XINU_SIMULATION_C")
        
        with open(self.config.sim_helper_c, 'w') as f:
            f.write(content)
            
        log(f"Generated UNIX-like simulation helper at: {self.config.sim_helper_c}")

    def generate_xinu_core(self):
        """Generate a simple xinu_core.c if it doesn't exist"""
        xinu_core_path = self.config.xinu_core_c
        
        # Only generate if it doesn't exist
        if not os.path.exists(xinu_core_path):
            content = self._render_template("XINU_CORE_C")
            
            with open(xinu_core_path, 'w') as f:
                f.write(content)
                
            log(f"Generated minimal XINU core at: {xinu_core_path}")

    def auto_insert_includes(self):
        """Automatically insert necessary includes in source files"""
        log("Automatically inserting missing includes in source files...")
        
        # Define directories to scan
        dirs_to_scan = [
            self.config.include_dir,
            self.config.system_dir,
            self.config.device_dir,
            self.config.shell_dir,
            self.config.libxc_dir
        ]
        
        # Find all .c and .h files
        all_files = []
        for directory in dirs_to_scan:
            if os.path.exists(directory):
                for root, _, files in os.walk(directory):
                    for file in files:
                        if file.endswith(('.c', '.h')):
                            all_files.append(os.path.join(root, file))
        
        # Exclude generated files
        excluded_files = [
            self.config.stddefs_h,
            self.config.includes_h,
            self.config.sim_decls_h,
            self.config.sim_helper_c,
            self.config.xinu_h
        ]
        
        files_to_process = [f for f in all_files if f not in excluded_files]
        
        # Process each file
        for file_path in files_to_process:
            self._ensure_includes_in_file(file_path)
            
    def _ensure_includes_in_file(self, file_path):
        """Ensure necessary includes are in a file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
                
            # Check if file needs stddef.h
            needs_stddef = 'size_t' in content and '#include <stddef.h>' not in content
            
            # Check if file needs xinu.h
            xinu_patterns = ['syscall', 'int32', 'did32', 'XINU_', 'PROC', 'prstate', 'proctab', 'clktime']
            needs_xinu = any(pattern in content for pattern in xinu_patterns) and \
                       '#include <xinu.h>' not in content and '#include "xinu.h"' not in content
                       
            if not needs_stddef and not needs_xinu:
                return False
                
            # Find position to insert includes
            includes = []
            if needs_stddef:
                includes.append('#include <stddef.h>')
            if needs_xinu:
                includes.append('#include <xinu.h>')
                
            # Find the last include or the first non-comment, non-pragma, non-define line
            lines = content.splitlines()
            last_include_idx = -1
            first_code_idx = -1
            
            for i, line in enumerate(lines):
                if line.strip().startswith('#include'):
                    last_include_idx = i
                if first_code_idx == -1 and not line.strip().startswith(('#', '/*', '*', '//')):
                    first_code_idx = i
                    
            # Determine insertion point
            if last_include_idx != -1:
                insertion_idx = last_include_idx + 1
            elif first_code_idx != -1:
                insertion_idx = first_code_idx
            else:
                insertion_idx = 0
                
            # Insert includes
            updated_lines = lines[:insertion_idx] + includes + lines[insertion_idx:]
            updated_content = '\n'.join(updated_lines)
            
            # Write the updated content
            with open(file_path, 'w') as f:
                f.write(updated_content)
                
            if needs_stddef:
                log(f"Inserted <stddef.h> in {os.path.basename(file_path)}")
            if needs_xinu:
                log(f"Inserted <xinu.h> in {os.path.basename(file_path)}")
                
            return True
        except Exception as e:
            log(f"Error updating includes in {file_path}: {str(e)}")
            return False
